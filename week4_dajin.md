# Sopt 4주차 - Cloud

## ✨ Infra

> IT 시스템의 기본적인 물리적, 논리적 기반 구조
>
- 클라우드 인프라에서는 물리적인 서버와 네트워크가 클라우드 서비스에 의해 관리되고, 사용자는 이 인프라를 원격으로 접근하여 필요한 컴퓨팅 리소스를 사용한다.

## ✨ Cloud

> 인터넷을 통해 접근할 수 있는 서버, DB, 소프트웨어 같은 컴퓨팅 자원
>
- 클라우드를 사용하면 물리적인 서버나 하드웨어를 직접 소유하고 유지 관리할 필요 없다.
- Cloud Computing : 컴퓨팅 서비스를 인터넷을 통해 제공하는 것이다.
    - 왜 Cloud Computing을 사용할까?
        - 관심사의 분리 : 사용자는 클라우드 서비스가 내부적으로 어떻게 동작하는지 알 필요가 없다. 사용자는 데이터를 요청하고 그에 대한 응답만 받을 뿐, 실제 어떻게 서버가 작동하는지 알 필요가 없으므로 개발자들이 사용자가 실제 필요한 기능 개발에 집중할 수 있게 한다.
        - 역할과 책임의 분리 : 클라우드 서비스는 인프라 관리, 보안, 유지 관리를 담당하며 개발자는 서버 관리, 네트워킹의 부담을 덜고 오직 개발에만 집중 할 수 있다.

## ✨ Deploy 배포

> 클라우드 환경에서는 배포가 클라우드 리소스를 구성하여 애플리케이션이나 서비스를 호스팅 하는 것을 포함한다.
>
- 네이버클라우드 : 네이버 클라우드 콘솔을 통해 손쉽게 배포 가능하다.
- AWS : 가상 서버 인스턴스(E2C)를 설정하고, DB를 구성(RDS)하며, 애플리케이션이 사용자에게 접근 가능하도록 설정(VPC)하는 작업이다.

## ✨네트워크 - 망

> subnet : 큰 네트워크를 작은 네트워크들로 분할한 것
>
- 서버 IP 주소가 같아 보이는 이유
    - 서버들이 같은 네트워크에 속해 있을 떄는 같은 IP 대역을 사용할 수 있다. 클라우드에서 같은 대역의 IP를 사용한다고 해서 충돌이 일어나는 것이 아니라, 각 네트워크가 독립적으로 격리되어 있기 때문에 서로 영향을 받지 않는다.
        - 네트워크 격리? - 클라우드에서 각 서버나 그룹을 다른 네트워크처럼 분리하는 것이다. 클라우드 제공자가 하나의 클라우드 안에서 여러 사용자를 격리된 상태로 운영할 수 있게 해주는 기술이다.
        - 내부 IP는 외부에서는 볼 수 없고 서버들끼리 통신할 때만 사용된다. 외부에서 접근할 때는 외부 IP를 사용하므로 서버들은 격리된 상태에서 독립적으로 운영될 수 있다.

  → 각 학급이 하나의 네트워크라고 할 때, 여러 학급에 “다진”이라는 이름을 가진 학생이 있어도 각 학급 안에서는 “다진”이가 고유한 사람이다. 다른 학급 다진이들과 겹치지 않는 것처럼.

- VPC
    - 클라우드에서 논리적으로 분리된 가상 네트워크 공간이다. 이 안에서는 가상 머신 같은 리소스를 실행할 수 있으며, IP 주소 대역, 서브넷, 라우팅 테이블 네트워크 게이트웨이 등을 정의하여 각 네트워크를 분리하고 관리할 수 있다.
        - 논리적 : 같은 물리적 하드웨어를 사용하더라도 설정을 통해 각 사용자가 고유한 네트워크로 인식하도록 하는 것
        - 물리적 : 서로 다른 물리적 하드웨어를 사용하는 것
    - VPC는 공용 클라우드 안에서 개인적이고 보안이 강화된 네트워크를 만드는 것이다. VPC 내부의 리소스는 격리되어 있으며 특정 구성을 통해서만 접근이 가능하다.

## ✨동적 프록시 vs CGLIB

> 한 클래스 안에서 여러 @Transactional 메서드를 사용하려면 CGLIB방식을 선택하는 것이 좋다.
>
- Transactional : 데이터의 일관성을 유지하기 위해 작업을 하나로 묶는 것이다.
    - 은행에서 돈을 이체할 때 돈을 빼고, 넣는 두 가지 작업이 성공해야만 이체가 완료된다고 볼 수 있다. 만약 하나라도 실패하면 모든 작업이 취소된다.
- 프록시 : 다른 객체(클래스)를 대신하여 그 역할을 수행하는 것이다.
- 동적 프록시 : Java의 기본 기능을 이용해서 만들어진다. 자바에서는 인터페이스를 가지고 있을 때, 이 인터페이스를 구현한 프록시 객체를 자동으로 생성한다.
    - 동적 프록시는 “인터페이스”가 있을 때만 사용가능하다.
    - 인터페이스 A가 있고, A를 구현한 클래스 B가 있다고 가정할 대, 동적 프록시는 A인터페이스를 구현하는 새로운 프록시 객체를 자동으로 만들어서 실제로는 B클래스 대신 이 프록시 객체가 일을 처리한다.

    ```java
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    
    public interface Service {
        void performAction();
    }
    
    public class DynamicProxyExample {
        public static void main(String[] args) {
            // 실제 구현 없이 프록시 객체만 생성
            Service proxyInstance = (Service) Proxy.newProxyInstance(
                Service.class.getClassLoader(),  // 클래스 로더 지정
                new Class[]{Service.class},  // 구현할 인터페이스 지정
                (proxy, method, args1) -> {  // InvocationHandler 구현 (람다 표현식)
                    System.out.println("프록시: 메서드 호출 전 작업 수행"); 
                    // 메서드 호출 없이 프록시에서 동작만 수행할 경우, result 없이 null 반환
                    System.out.println("프록시: 메서드 호출 후 작업 수행");
                    return null; // 수행 결과가 없으므로 null 반환
                });
    
            // 프록시 객체로 메서드 호출
            proxyInstance.performAction();
        }
    }
    ```

- CGLIB 프록시 : 인터페이스 없이 클래스를 상속받아 프록시 객체를 생성할 수 있도록 해주는 외부 라이브러리이다.
    - CGLIB은 클래스를 상송해서 프록시를 만들기 때문에 인터페이스 없이 사용 가능하다.
    - 만약 클래스 C가 있고, 인터페이스 없이 C클래스 자체에 기능을 추가하고 싶다면, CGLIB프록시가 C 클래스를 상속받아 새로운 프록시 객체를 만들어준다.

    ```java
    import net.sf.cglib.proxy.Enhancer;
    import net.sf.cglib.proxy.MethodInterceptor;
    import net.sf.cglib.proxy.MethodProxy;
    
    public class CGLibProxyExample {
        public static void main(String[] args) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(Service.class); // 상속할 대상 클래스 설정 (Service 인터페이스 상속)
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                    System.out.println("CGLIB 프록시: 메서드 호출 전 작업 수행");
                    // 실제 메서드가 없으므로 super 호출 없이 프록시 작업만 수행
                    System.out.println("CGLIB 프록시: 메서드 호출 후 작업 수행");
                    return null; // 수행 결과가 없으므로 null 반환
                }
            });
    
            // 프록시 생성
            Service proxyInstance = (Service) enhancer.create();
    
            // 프록시 객체로 메서드 호출
            proxyInstance.performAction();
        }
    }
    ```

- 동적 프록시와 CGLIB 프록시 차이로 인해 발생하는 문제
    - 한 클래스 안에서 여러 @Transactional 메서드를 호출할 때 문제가 생길 수 있다. 이 문제를 이해하기 위해 프록시가 어떻게 트랜잭션을 관리하는지 먼저 살펴보면,
    - 동적 프록시는 인터페이스를 통해서만 프록시 객체를 생성하므로 클래스의 외부에서 트랜잭션이 적용된 메서드를 호출할 때는 트랜잭션이 잘 작동하지만, 같은 클래스 내부에서 다른 트랜잭션 메서드를 호출하면 프록시를 거치지 않게 된다. 따라서 한 클래스 안에서 서로 다른 트랜잭션 메서드를 호출할 경우 트랜잭션이 정상적으로 적용되지 않을 수 있다.
    - CGLIB은 클래스를 상속하여 프록시 객체를 만든다. 즉, 같은 클래스 내부에서도 CGLIB프록시는 트랜잭션을 적용할 수 있다. 따라서 CGLIB방식에서는 한 클래스 안에서 여러 트랜잭션 메서드를 호출해도 트랜잭션이 정상적으로 작동한다.

## ✨네이버 클라우드

> 한 클래스 안에서 여러 @Transactional 메서드를 사용하려면 CGLIB방식을 선택하는 것이 좋다.
>

![스크린샷 2024-11-07 192636.png](..%2FUsers%2Fdidek%2FOneDrive%2F%EB%B0%94%ED%83%95%20%ED%99%94%EB%A9%B4%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-11-07%20192636.png)
- 인증키 : 서버에 접속하기 위해 사용하는 보안 키이다. 클라우드 환경에서 서버를 생성할 때 함께 제공되며, SSH 접속을 통해 서버에 로그인할 때 이 키를 사용한다.
    - 인증키를 통해 서버의 접근 권한을 제어아고, 외부에서 서버에 안전하에 접속할 수 있도록 한다.
- 스토리지 : 서버에 데이터를 저장하는 공간이다.
    - 클라우드 서버가 운영체제와 애플리케이션, 데이터 등을 저장할 수 있는 물리적 저장소이다.
- VCP : 클라우드 내에서 논리적으로 분리된 네트워크 공간이다. 사용자 전용 네트워크 공간을 만들고, 이 안에 서버를 배치하여 외부와 격리된 안전한 환경을 제공한다.
    - 서버간의 보안과 네트워크 구성을 효과적으로 관리할 수 있게 해준다.
- 서버 스펙 : 서버의 하드웨어 성능을 타나탠다.
    - 서버의 연산 성능과 메모리 크기, 저장 공간등을 나타낸다. 스펙이 높을수록 더 많은 작업을 동시에 수행할 수 있다. → 가격이 비싸진다.
- Subnet : VPC내에서 IP 주소 대역을 나누어 관리하기 위한 작은 네트워크
    - 외부와 연결되는 웹 서버와 데이터베이스 서버를 서로 다른 서브넷에 배치하여 보안을 강화할 수 있다.
- OS 정보: OS정보는 서버에 설치된 운영체제
    - CentOS는 리눅스 기반의 운영체제이다.