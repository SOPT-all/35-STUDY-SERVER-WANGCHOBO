# 4주차 세미나 복습

## Cloud

- Cloud는 인터넷을 통해 원격으로 접근할 수 있는 모든 것을 의미한다
- Cloud 특성을 활용해 원격의 컴퓨팅 리소스를 인터넷을 통해 보다 쉽게 관리할 수 있다
- 따라서 관심사 분리가 가능해 우리가 집중할 대상에 보다 집중할 수 있게끔 돕는다

## 프록시와 동적 프록시

### 1) 프록시

- 대리자/중계자라는 뜻으로 어떤 객체를 대신해 그 객체의 기능을 제공
- 프록시는 타겟 코드의 수정 없이 접근 제어 및 부가 기능을 추가하기 위해 사용되는 것
- 프록시의 사용을 위해서는 대상 클래수 만큼 프록시 클래스를 만들어야 함 + 이 과정에서 코드가 중복되기도 한다 -프록시 객체는 대상 객체와 같은 인터페이스를 구현하며, 대상 객체의 메서드 호출을 중계하는 역할

### 2) 동적 프록시

- 기존 프록시의 단점을 보완해 컴파일 시점이 아닌 런타인 시점에 프록시 클래스를 만들어 주는 방식
- 즉, 프로그램 실행 중에 생성되는 것
- 하나의 프록시 클래스로 여러 인터페이스의 구현체를 대신할 수 있음
- 공통 기능을 프록시 클래스에 구현 시 코드의 중복을 효과적으로 개선할 수 있다
- 대표적인 예시 : AOP, 원격 메서드 호출, 리소스 관리

- `newProxyInstance()` 메서드

```java
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
```

- ClassLoader : 프록시 클래스를 만들 클래스로더
- Class : 프록시 클래스가 구현할 인터페이스 목록(배열)
- InvocationHandler : 메서드가 호출되었을때 실행될 핸들러

-> 런타임 시점에 프록시 클래스를 생성해 대상 클래스 수만큼 프록시 클래스를 만ㄷ르어야 하는 단점 극복 가능!

- `InvocationHanlder`

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

- Object : 프록시 객체
- Method : 호출한 메서드 정보
- Object[] : 메서드에 전달된 파라미터

- invoke() 메서드만 가지고 있는 인터페이스
- invoke()를 통해 어떤 시점에서 어떤 메서드가 실행되었는지 메서드 정보, 전달 인자를 알 수 있다
- 프록스 사용 시 중복된 클래스를 한 번만 작성하게 해 코드의 중복을 줄인다

## 동적 프록시 활용의 장단점

- (+) 다양한 타입의 객체에 대해 동일한 프록시 클래스의 활용이 가능해 유연한 코드 작성 가능
- (+) 공통적인 기능을 프록시에서 처리해 중복 줄일 수 있음
- (+) 공통 기능 변경 시 프록시 클래스만 수정하면 돼 유지보수의 용이

- (-) 프록시 사용으로 인해 시스템 복잡성 증가
- (-) 클래스 기반 동적 프록시 사용 시 라이브러리 의존성 발생
- (-) 인터페이스 기반 동적 프록시 사용 시 반드시 인터페이스를 사용하는 클래스 구조로 설계해야 함
- (-) 추가적인 메서드 호출과 리플렉션 사용으로 인한 성능 저하 발생 가능

=> 등족 프록시 사용 시 프록시를 적용할 코드 하나만 만들어 두고 동적 프록시 기술을 활용해 프록시 객체를 런타임 시점에만 생성해 줘 더 효율적으로 코드를 작성할 수 있다!
