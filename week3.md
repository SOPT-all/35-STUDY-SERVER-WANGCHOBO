# 3주차 세미나

## Database의 역할

- 1/2주차에서는 client <-> db를 다뤘다면, 3주차에서는 server <-> db 를 다룸.
- 보통 server <-> db 사이의 로직에서 문제가 발생하며, 역할을 분리해야 문제를 빠르게 해결할 수 있고 의존성을 낮출 수 있다.
- 서버에서도 memory에 데이터를 저장할 수 있지만, 비용과 휘발성으로 인해 DB를 통해 역할을 분리한다.

## RDB vs NoSQL

1. RDB(관계형 데이터 베이스): DB schema를 요구하는 table 기반 데이터 구조

2. NoSQL: table 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원

## RDB

-   mysql을 많이 사용하는 이유는 상대적으로 저렴한 비용과 효율을 극대화할 수 있기 때문!
-   테이블을 하나에 모두 작성할 수 있지만, 정형화한다.(테이블 분리)
-   데이터를 잘 구분하기 위해 식별자를 넣는 것이며, 인텍스를 통해 빠른 검색이 가능함

## DB를 다루기 위한 언어, query

-   DB와의 소통을 위해 필요한 언어이며, CRUD 기능에 사용
-   데이터를 정의하는 DDL과 데이터를 조작하는 DML을 잘 구분할 줄 알아야 함.
-   DDL(Create, Alter, Drop)은 데이터를 넣는 틀을 다루는 것이고, DML(Select, Insert, Update, Delete)은 테이블 내 데이터를 다루는 것이다.

# 3주차 미미나 JDBC, JPA, Transaction

## JDBD

-   Java Database Connectivity로, 원시적인 방법에서부터 벗어나 DB 연결 및 통신을 편하게 해주는 도구
    -> 커넥션 맺기 -> 쿼리 작성 -> 쿼리 요청 -> 응답을 클래스에 바인딩 -> 커넥션 종료
-   JDBC는 위의 원시적인 방법에 편리함을 준다.
    -> 커넥션 맺기(맺는 과정 제공) -> 쿼리 작성(직접 String으로 쿼리를 쓰지 않는 방식 제공) -> 쿼리 요청(쿼리 요청) -> 응답을 클래스에 바인딩(응답 온 결과를 읽어줌, 바인딩은 직접) -> 커넥션 종료(직접 반납해야 함)
-   즉, 개발자가 개발에 집중하기 위해 만들어준 것. 그런데 이것마저도 불편해서 생긴게 JPA, JDBCTemplate 등등

## JPA

-   Java Persistence API
-   JDBC를 orm 기반으로 wrapping한 게 JPA이다
-   DB 관점으로 보지 말고, 객체지향 관점으로 바라보자 !

## hibernate

-   JPA를 구현해놓은 것
    -> JPA와 Hibernate는 우리를 편하게 해주는 도구이다

## JDBC, JPA, Hibernate, Spring Data JPA 관계

( ((( jdbc ) ORM 기반으로 : JPA ) ← hibernate ) Spring 위에서 편하게 띄어지게 : Spring Data JPA)

## JPA는 항상 옳은가?

-   의도치 않은 쿼리가 발생할 수 있음

```
deleteById() -> delete from ~ where id=?
    * select from where id=?
    * delete
```

-   FK를 강제하게 된다.
    -   FK는 무결성을 위한 값이나, 성능과 trade-off
        -   FK를 위해 db안에서 처리할 것이 많은데 data 수가 많다면 CPU에 과부하가 올 수 있다

## Transaction

-   트랜잭션은 DB 관리 시스템 또는 유사한 시스템에서의 상호작용 단위로 데이터 정합성을 보장하기 위한 방법
    -> 동시 접근하는 여러 프로그램 간 격리를 제공
    -> 오류로부터의 복구 허용 및 DB 일관성 있게 유지하는 안정적 작업 단위 제공
-   즉, 쉽게 말해 내 처리 흐름을 보장해주는 장치이다.

## Transaction의 특징 <ACID>

1. 원자성(Atomicity): 트랜잭션이 단일 단위로 처리해 완전히 성공 또는 실패로만 처리되도록 함
2. 일관성(Consistency): 트랜잭션의 성공적 완료 시 언제나 동일한 데이터베이스 상태로 유지
3. 독립성(Isolation): 트랜잭션 수행 시 다른 트랜잭션의 그 어떤 작업도 개입하지 못함
4. 지속성(Durability): 성공적으로 수행된 트랜잭션의 결과는 영원히 반영되어 있어야 함

## Transaction의 연산

1. commit: 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성이 있는 상태로 유지될 때 트랜잭션이 마무리되었다는 것을 알리기 위한 연산
2. rollback: 트랜잭션 처리가 비정상적으로 종료된 경우, 트랜잭션을 다시 시작하거나, 트랜잭션의 부분적으로 연산한 결과를 취소시키는 연산

## Spring에서 Transaction 적용 방법

-   선언적 트랜잭션
    -> 설정 파일 또는 어노테이션 방식으로 간편하게 트랜잭션에 관한 행위를 정의하는 것
-   어노테이션을 이용한 설정을 알아보겠다.

## 어노테이션을 이용한 트랜잭션 설정

-   @Transactional을 클래스 또는 메서드 단위에 선언
-   Transactional 어노테이션 추가 시 Dirty Checking을 하게 되고, 데이터베이스에 commit을 해서 수정된 사항을 save 없이도 반영할 수 있도록 함
    -> JPA에서는 트랜잭션이 끝나는 시점에 변화가 생긴 모든 엔티티들을 데이터베이스에 자동으로 반영
    -> JPA의 영속성 컨텍스트(Persistence Context)가 수행하는 변경 감지(Dirty Checking)
    -> 쉽게 말하자면, Drity Checking은 상태 변경 검사를 의미

## 트랜잭션은 언제 사용하면 좋을까?

-> 주로 비즈니스 로직이 담겨있는 서비스 레이어에서 트랜잭션 처리 \* 데이터 저장을 하는 레포지토리 레이어에서 읽어온 데이터들을 읽기, 수정, 저장 등의 작업을 하는 곳이 서비스 레이어이기에.

## @Transactional(readOnly = true)는?

-> 읽기 전용(조회용) 메서드임을 선언하는 것
-> JPA는 해당 트랜잭션 내에서 조회하는 Entity가 조회용임을 인식하고, 변경 감지를 위한 Snapshot을 따로 보관하지 않으므로, 메모리가 절약되는 성능삭의 이점이 존재함
