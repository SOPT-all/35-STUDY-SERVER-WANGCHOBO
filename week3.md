# DB의 역할

데이터베이스 DB를 통해 데이터를 Disk에 온전히, 영구적으로 저장
이때, Spring과의 의존이 최소화되도록 인프라를 구성해야 함
-> 서버가 죽더라도 두 프로세스 모두 죽지 않도록!

DB와 Spring 각각의 프로세스의 역할을 명확히 분리할 것

# DB의 종류
 
1. RDB 관게형 데이터 베이스
   `join`으로 관계를 맺게 되고, 이를 통해 서버에서 데이터를 정합성 있게 조회
   즉, RDB는 데이터 스키마 간에 관계를 맺게 된다

2. 데이터 식별자
   데이터를 '잘' 저장하기 위해서는 데이터가 잘 정리될 수 있도록 데이터의 UIQUE를 보장해 줘야 한다.
   이때, PK라 불리는 기본키 식별자로 데이터의 유니크를 보장한다.

3. 쿼리
   DB와의 소통을 위해 필요한 언어를 뜻한다.
   관계형 데이터 베이스에 데이터의 저장, 조회, 조작에 사용

3-1) DDL: 데이터 정의어

> Create, Alter, Drop

3-2) DML: 데이터 조작어

> Selece, Insert, Update, Delete

# DB와 Server 실제로 연결하기

+) DB 접근 정보가 담긴 파일 yml이 노출되어서는 안 된다
+) auto-ddl DB데이터가 유실되지 않게 조심해야 한다

Client -> Controller에서 DTO로 받은 뒤 Service로 전달 -> Service에서 Entity로 바꾸어 Repository로 전달
JPA, MySQL dependency를 추가하고, resources 패키지 내부에 application.yml 파일을 추가해 환경세팅하기

# @Transactional 이해하기 - 미미나... 내용

- 트랜잭션은 DB 관리 시스템 혹은 유사한 시스템에서의 상호작용 단위로 데이터 정합성을 보장하기 위한 방법
  -> 동시 접근하는 여러 프로그램 간 격리를 제공
  -> 오류로부터의 복구 허용 및 DB 일관성 있게 유지하는 안정적 작업 단위 제공

- Transaction의 특징 <ACID>
  -> 원자성 + 일관성 + 독립성 + 지속성의 약자를 딴 단어
  -> 트랜잭션이 단일 단위로 처리해 완전히 성공 / 실패 로만 처리되도록 함
  -> 트랜잭션의 성공적 완료 시 언제나 동일한 데이터베이스 상태로 유지
  -> 트랜잭션 수행 시 다른 트랜잭션의 그 어떤 작업도 개입하지 못함
  -> 성공적으로 수행된 트랜잭션의 결과는 영원히 반영되어 있어야 함

- 트랜잭션의 과정
  -> 트랜잭션 시작 -> 비즈니스 로직 실행 -> 트랜잭션 커밋...

- 트랜잭션 사용 이유
  -> 데이터베이스 상태의 변화를 위해 수행하는 작업 단위를 의미
  -> Transactional 어노테이션 추가 시 Dirty Checking을 하게 되고, 이터베이스에 commit을 해서 수정된 사항을 save 없이도 반영할 수 있도록 함
  -> JPA에서는 트랜잭션이 끝나는 시점에 변화가 생긴 모든 엔티티들을 데이터베이스에 자동으로 반영
  +) JPA의 영속성 컨텍스트(Persistence Context)가 수행하는 변경 감지(Dirty Checking)
  간단히 말하자면... Drity Checking은 상태 변경 검사를 의미

- 트랜잭션 언제 사용하면 좋을까?
  -> 주로 비즈니스 로직이 담겨있는 서비스 레이어에서 트랜잭션 처리
  -> 데이터 저장을 하는 레포지토리 레이어에서 읽어온 데이터들을 읽기, 수정, 저장 등의 작업을 하는 곳이 서비스 레이어이기 때문!

- @Transactional(readOnly = true)는?
  -> 조회용 메서드임을 선언하는 것
  -> JPA는 해당 트랜잭션 내에서 조회하는 Entity가 조회용임을 인식, 변경 감지를 위한 Snapshot을 따로 보관하지 않음
  -> 메모리 절약되는 성능상의 이점 존재
